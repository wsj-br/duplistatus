#!/bin/sh
#
# Admin Recovery Script (shell)
#
# Resets a user's password directly in the SQLite database.
# Uses Node.js + bcrypt (already required by the app) to generate the password hash.
#
# Usage:
#   admin-recovery <username> <new-password>
#
# Example:
#   admin-recovery admin NewPassword123

set -eu

usage() {
  echo "Usage: admin-recovery <username> <new-password>" >&2
  echo "Example: admin-recovery admin NewPassword123" >&2
}

if [ "${1-}" = "" ] || [ "${2-}" = "" ]; then
  echo "âŒ Error: Missing required arguments" >&2
  usage
  exit 1
fi

USERNAME="$1"
NEW_PASSWORD="$2"

# Determine project root (works both locally and in Docker)
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"
if [ ! -f "$PROJECT_ROOT/package.json" ] && [ -f "$PROJECT_ROOT/../package.json" ]; then
  PROJECT_ROOT="$(cd "$PROJECT_ROOT/.." && pwd)"
fi

cd "$PROJECT_ROOT"

DATA_DIR="$PROJECT_ROOT/data"
DB_PATH="$DATA_DIR/backups.db"

if [ ! -f "$DB_PATH" ]; then
  echo "âŒ Error: Database not found at $DB_PATH" >&2
  echo "Make sure the application has been initialized." >&2
  exit 1
fi

# Audit logging function
# Usage: log_audit <status> <error_message>
# status: 'success' or 'failure'
# error_message: optional error message (only for failures)

log_audit() {
  
  status="$1"
  error_msg="${2:-}"
  
  # Check if audit_log table exists
  audit_table="$(sqlite3 "$DB_PATH" "SELECT name FROM sqlite_master WHERE type='table' AND name='audit_log';" 2>/dev/null || true)"
  if [ "$audit_table" != "audit_log" ]; then
    echo "âŒ Warning: Audit log table not found" >&2
    return 0
  fi
  
  # Build details JSON payload
  # Escape JSON special characters in error message: backslash, double quote
  if [ -n "$error_msg" ]; then
    escaped_error="$(printf "%s" "$error_msg" | sed 's/\\/\\\\/g; s/"/\\"/g')"
    details_json="{\"targetUser\":\"$USERNAME\",\"method\":\"cli\",\"error\":\"$escaped_error\"}"
  else
    details_json="{\"targetUser\":\"$USERNAME\",\"method\":\"cli\"}"
  fi
  
  # Escape single quotes for SQLite
  details="$(printf "%s" "$details_json" | sed "s/'/''/g")"
  
  # write the audit logging on the database
  sqlite3 "$DB_PATH" "INSERT INTO audit_log (action, category, status, username, details, timestamp) VALUES ('admin_password_reset_cli','system','$status','system','$details',CURRENT_TIMESTAMP);" 2>/dev/null || true
}

# Password policy (keep in sync with src/lib/auth.ts)
DEFAULT_PASSWORD="Duplistatus09"
MIN_LEN=8

if [ "$NEW_PASSWORD" = "$DEFAULT_PASSWORD" ]; then
  echo "âŒ Error: Cannot use the default password. Please choose a different password" >&2
  exit 1
fi

pass_len="${#NEW_PASSWORD}"
if [ "$pass_len" -lt "$MIN_LEN" ]; then
  echo "âŒ Error: Password must be at least ${MIN_LEN} characters long" >&2
  exit 1
fi

echo "$NEW_PASSWORD" | grep -q '[A-Z]' || { echo "âŒ Error: Password must contain at least one uppercase letter (A-Z)" >&2; exit 1; }
echo "$NEW_PASSWORD" | grep -q '[a-z]' || { echo "âŒ Error: Password must contain at least one lowercase letter (a-z)" >&2; exit 1; }
echo "$NEW_PASSWORD" | grep -q '[0-9]' || { echo "âŒ Error: Password must contain at least one number (0-9)" >&2; exit 1; }

# Verify required tables exist
users_table="$(sqlite3 "$DB_PATH" "SELECT name FROM sqlite_master WHERE type='table' AND name='users';")"
if [ "$users_table" != "users" ]; then
  echo "âŒ Error: Users table not found" >&2
  echo "The database may not have been migrated to a version with authentication yet." >&2
  exit 1
fi

# Escape single quotes for SQLite string literals
ESC_USERNAME="$(printf "%s" "$USERNAME" | sed "s/'/''/g")"

user_row="$(sqlite3 "$DB_PATH" "SELECT id, username, is_admin, locked_until FROM users WHERE username = '$ESC_USERNAME' LIMIT 1;")"
if [ -z "$user_row" ]; then
  echo "âŒ Error: User '$USERNAME' not found" >&2
  log_audit "failure" "User not found"
  exit 1
fi

echo "ðŸ” Hashing new password..."
HASH="$(node -e "const bcrypt=require('bcrypt'); bcrypt.hash(process.argv[1], 12).then(h=>process.stdout.write(h)).catch(e=>{console.error(e?.message||String(e)); process.exit(1);});" "$NEW_PASSWORD")"

if [ -z "$HASH" ]; then
  echo "âŒ Error: Failed to hash password (empty hash)" >&2
  log_audit "failure" "Failed to hash password (empty hash)"
  exit 1
fi

ESC_HASH="$(printf "%s" "$HASH" | sed "s/'/''/g")"

# Verify user still exists before attempting update
user_check="$(sqlite3 "$DB_PATH" "SELECT id FROM users WHERE username = '$ESC_USERNAME' LIMIT 1;")"
if [ -z "$user_check" ]; then
  echo "âŒ Error: User '$USERNAME' does not exist" >&2
  log_audit "failure" "User does not exist"
  exit 1
fi

echo "ðŸ“ Resetting password for user '$USERNAME'..."
# Check if UPDATE was successful and affected at least one row
rows_affected="$(sqlite3 "$DB_PATH" "UPDATE users SET password_hash = '$ESC_HASH', must_change_password = 0, failed_login_attempts = 0, locked_until = NULL, updated_at = CURRENT_TIMESTAMP WHERE username = '$ESC_USERNAME'; SELECT changes();")"
if [ -z "$rows_affected" ] || [ "$rows_affected" = "0" ]; then
  echo "âŒ Error: Failed to update password. No rows were affected." >&2
  log_audit "failure" "Failed to update password. No rows were affected."
  exit 1
fi

# Log successful password reset
log_audit "success"

echo "âœ… Password reset successfully for user '$USERNAME'"


